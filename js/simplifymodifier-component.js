const BufferAttribute = THREE.BufferAttribute, BufferGeometry = THREE.BufferGeometry, Float32BufferAttribute = THREE.Float32BufferAttribute, InstancedBufferAttribute = THREE.InstancedBufferAttribute, InterleavedBuffer = THREE.InterleavedBuffer, InterleavedBufferAttribute = THREE.InterleavedBufferAttribute, TriangleFanDrawMode = THREE.TriangleFanDrawMode, TriangleStripDrawMode = THREE.TriangleStripDrawMode, TrianglesDrawMode = THREE.TrianglesDrawMode, Vector3 = THREE.Vector3; function computeMikkTSpaceTangents(e, t, r = !0) { if (!t || !t.isReady) throw Error("BufferGeometryUtils: Initialized MikkTSpace library required."); if (!e.hasAttribute("position") || !e.hasAttribute("normal") || !e.hasAttribute("uv")) throw Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.'); function i(e) { if (e.normalized || e.isInterleavedBufferAttribute) { let t = new Float32Array(e.count * e.itemSize); for (let r = 0, i = 0; r < e.count; r++)t[i++] = e.getX(r), t[i++] = e.getY(r), e.itemSize > 2 && (t[i++] = e.getZ(r)); return t } return e.array instanceof Float32Array ? e.array : new Float32Array(e.array) } let o = e.index ? e.toNonIndexed() : e, n = t.generateTangents(i(o.attributes.position), i(o.attributes.normal), i(o.attributes.uv)); if (r) for (let s = 3; s < n.length; s += 4)n[s] *= -1; return o.setAttribute("tangent", new BufferAttribute(n, 4)), e !== o && e.copy(o), e } function mergeGeometries(e, t = !1) { let r = null !== e[0].index, i = new Set(Object.keys(e[0].attributes)), o = new Set(Object.keys(e[0].morphAttributes)), n = {}, s = {}, u = e[0].morphTargetsRelative, l = new BufferGeometry, a = 0; for (let f = 0; f < e.length; ++f){ let m = e[f], g = 0; if (r !== (null !== m.index)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + f + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null; for (let h in m.attributes) { if (!i.has(h)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + f + '. All geometries must have compatible attributes; make sure "' + h + '" attribute exists among all geometries, or in none of them.'), null; void 0 === n[h] && (n[h] = []), n[h].push(m.attributes[h]), g++ } if (g !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + f + ". Make sure all geometries have the same number of attributes."), null; if (u !== m.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + f + ". .morphTargetsRelative must be consistent throughout all geometries."), null; for (let c in m.morphAttributes) { if (!o.has(c)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + f + ".  .morphAttributes must be consistent throughout all geometries."), null; void 0 === s[c] && (s[c] = []), s[c].push(m.morphAttributes[c]) } if (t) { let d; if (r) d = m.index.count; else { if (void 0 === m.attributes.position) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + f + ". The geometry must have either an index or a position attribute"), null; d = m.attributes.position.count } l.addGroup(a, d, f), a += d } } if (r) { let b = 0, p = []; for (let $ = 0; $ < e.length; ++$){ let A = e[$].index; for (let v = 0; v < A.count; ++v)p.push(A.getX(v) + b); b += e[$].attributes.position.count } l.setIndex(p) } for (let y in n) { let B = mergeAttributes(n[y]); if (!B) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + y + " attribute."), null; l.setAttribute(y, B) } for (let w in s) { let x = s[w][0].length; if (0 === x) break; l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[w] = []; for (let T = 0; T < x; ++T){ let _ = []; for (let E = 0; E < s[w].length; ++E)_.push(s[w][E][T]); let I = mergeAttributes(_); if (!I) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + w + " morphAttribute."), null; l.morphAttributes[w].push(I) } } return l } function mergeAttributes(e) { let t, r, i, o = -1, n = 0; for (let s = 0; s < e.length; ++s){ let u = e[s]; if (u.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."), null; if (void 0 === t && (t = u.array.constructor), t !== u.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null; if (void 0 === r && (r = u.itemSize), r !== u.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null; if (void 0 === i && (i = u.normalized), i !== u.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null; if (-1 === o && (o = u.gpuType), o !== u.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null; n += u.array.length } let l = new t(n), a = 0; for (let f = 0; f < e.length; ++f)l.set(e[f].array, a), a += e[f].array.length; let m = new BufferAttribute(l, r, i); return void 0 !== o && (m.gpuType = o), m } function deepCloneAttribute(e) { return e.isInstancedInterleavedBufferAttribute || e.isInterleavedBufferAttribute ? deinterleaveAttribute(e) : e.isInstancedBufferAttribute ? new InstancedBufferAttribute().copy(e) : new BufferAttribute().copy(e) } function interleaveAttributes(e) { let t, r = 0, i = 0; for (let o = 0, n = e.length; o < n; ++o){ let s = e[o]; if (void 0 === t && (t = s.array.constructor), t !== s.array.constructor) return console.error("AttributeBuffers of different types cannot be interleaved"), null; r += s.array.length, i += s.itemSize } let u = new InterleavedBuffer(new t(r), i), l = 0, a = [], f = ["getX", "getY", "getZ", "getW"], m = ["setX", "setY", "setZ", "setW"]; for (let g = 0, h = e.length; g < h; g++){ let c = e[g], d = c.itemSize, b = c.count, p = new InterleavedBufferAttribute(u, d, l, c.normalized); a.push(p), l += d; for (let $ = 0; $ < b; $++)for (let A = 0; A < d; A++)p[m[A]]($, c[f[A]]($)) } return a } function deinterleaveAttribute(e) { let t = e.data.array.constructor, r = e.count, i = e.itemSize, o = e.normalized, n = new t(r * i), s; s = e.isInstancedInterleavedBufferAttribute ? new InstancedBufferAttribute(n, i, o, e.meshPerAttribute) : new BufferAttribute(n, i, o); for (let u = 0; u < r; u++)s.setX(u, e.getX(u)), i >= 2 && s.setY(u, e.getY(u)), i >= 3 && s.setZ(u, e.getZ(u)), i >= 4 && s.setW(u, e.getW(u)); return s } function deinterleaveGeometry(e) { let t = e.attributes, r = e.morphTargets, i = new Map; for (let o in t) { let n = t[o]; n.isInterleavedBufferAttribute && (i.has(n) || i.set(n, deinterleaveAttribute(n)), t[o] = i.get(n)) } for (let s in r) { let u = r[s]; u.isInterleavedBufferAttribute && (i.has(u) || i.set(u, deinterleaveAttribute(u)), r[s] = i.get(u)) } } function estimateBytesUsed(e) { let t = 0; for (let r in e.attributes) { let i = e.getAttribute(r); t += i.count * i.itemSize * i.array.BYTES_PER_ELEMENT } let o = e.getIndex(); return t + (o ? o.count * o.itemSize * o.array.BYTES_PER_ELEMENT : 0) } function mergeVertices(e, t = 1e-4) { t = Math.max(t, Number.EPSILON); let r = {}, i = e.getIndex(), o = e.getAttribute("position"), n = i ? i.count : o.count, s = 0, u = Object.keys(e.attributes), l = {}, a = {}, f = [], m = ["getX", "getY", "getZ", "getW"], g = ["setX", "setY", "setZ", "setW"]; for (let h = 0, c = u.length; h < c; h++){ let d = u[h], b = e.attributes[d]; l[d] = new BufferAttribute(new b.array.constructor(b.count * b.itemSize), b.itemSize, b.normalized); let p = e.morphAttributes[d]; p && (a[d] = new BufferAttribute(new p.array.constructor(p.count * p.itemSize), p.itemSize, p.normalized)) } let $ = Math.log10(1 / t), A = Math.pow(10, $); for (let v = 0; v < n; v++){ let y = i ? i.getX(v) : v, B = ""; for (let w = 0, x = u.length; w < x; w++){ let T = u[w], _ = e.getAttribute(T), E = _.itemSize; for (let I = 0; I < E; I++)B += `${~~(_[m[I]](y) * A)},` } if (B in r) f.push(r[B]); else { for (let V = 0, N = u.length; V < N; V++){ let G = u[V], z = e.getAttribute(G), U = e.morphAttributes[G], S = z.itemSize, R = l[G], X = a[G]; for (let C = 0; C < S; C++){ let M = m[C], H = g[C]; if (R[H](s, z[M](y)), U) for (let F = 0, q = U.length; F < q; F++)X[F][H](s, U[F][M](y)) } } r[B] = s, f.push(s), s++ } } let D = e.clone(); for (let k in e.attributes) { let Y = l[k]; if (D.setAttribute(k, new BufferAttribute(Y.array.slice(0, s * Y.itemSize), Y.itemSize, Y.normalized)), k in a) for (let Z = 0; Z < a[k].length; Z++){ let P = a[k][Z]; D.morphAttributes[k][Z] = new BufferAttribute(P.array.slice(0, s * P.itemSize), P.itemSize, P.normalized) } } return D.setIndex(f), D } function toTrianglesDrawMode(e, t) { if (t === TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e; if (t !== TriangleFanDrawMode && t !== TriangleStripDrawMode) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e; { let r = e.getIndex(); if (null === r) { let i = [], o = e.getAttribute("position"); if (void 0 === o) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let n = 0; n < o.count; n++)i.push(n); e.setIndex(i), r = e.getIndex() } let s = r.count - 2, u = []; if (t === TriangleFanDrawMode) for (let l = 1; l <= s; l++)u.push(r.getX(0)), u.push(r.getX(l)), u.push(r.getX(l + 1)); else for (let a = 0; a < s; a++)a % 2 == 0 ? (u.push(r.getX(a)), u.push(r.getX(a + 1)), u.push(r.getX(a + 2))) : (u.push(r.getX(a + 2)), u.push(r.getX(a + 1)), u.push(r.getX(a))); u.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); let f = e.clone(); return f.setIndex(u), f.clearGroups(), f } } function computeMorphedAttributes(e) { let t = new Vector3, r = new Vector3, i = new Vector3, o = new Vector3, n = new Vector3, s = new Vector3, u = new Vector3, l = new Vector3, a = new Vector3; function f(e, f, m, g, h, c, d, b) { t.fromBufferAttribute(f, h), r.fromBufferAttribute(f, c), i.fromBufferAttribute(f, d); let p = e.morphTargetInfluences; if (m && p) { u.set(0, 0, 0), l.set(0, 0, 0), a.set(0, 0, 0); for (let $ = 0, A = m.length; $ < A; $++){ let v = p[$], y = m[$]; 0 !== v && (o.fromBufferAttribute(y, h), n.fromBufferAttribute(y, c), s.fromBufferAttribute(y, d), g ? (u.addScaledVector(o, v), l.addScaledVector(n, v), a.addScaledVector(s, v)) : (u.addScaledVector(o.sub(t), v), l.addScaledVector(n.sub(r), v), a.addScaledVector(s.sub(i), v))) } t.add(u), r.add(l), i.add(a) } e.isSkinnedMesh && (e.applyBoneTransform(h, t), e.applyBoneTransform(c, r), e.applyBoneTransform(d, i)), b[3 * h + 0] = t.x, b[3 * h + 1] = t.y, b[3 * h + 2] = t.z, b[3 * c + 0] = r.x, b[3 * c + 1] = r.y, b[3 * c + 2] = r.z, b[3 * d + 0] = i.x, b[3 * d + 1] = i.y, b[3 * d + 2] = i.z } let m = e.geometry, g = e.material, h, c, d, b = m.index, p = m.attributes.position, $ = m.morphAttributes.position, A = m.morphTargetsRelative, v = m.attributes.normal, y = m.morphAttributes.position, B = m.groups, w = m.drawRange, x, T, _, E, I, V, N, G = new Float32Array(p.count * p.itemSize), z = new Float32Array(v.count * v.itemSize); if (null !== b) { if (Array.isArray(g)) for (x = 0, _ = B.length; x < _; x++)for (V = Math.max((I = B[x]).start, w.start), N = Math.min(I.start + I.count, w.start + w.count), T = V, E = N; T < E; T += 3)h = b.getX(T), f(e, p, $, A, h, c = b.getX(T + 1), d = b.getX(T + 2), G), f(e, v, y, A, h, c, d, z); else for (V = Math.max(0, w.start), N = Math.min(b.count, w.start + w.count), x = V, _ = N; x < _; x += 3)h = b.getX(x), f(e, p, $, A, h, c = b.getX(x + 1), d = b.getX(x + 2), G), f(e, v, y, A, h, c, d, z) } else if (Array.isArray(g)) for (x = 0, _ = B.length; x < _; x++)for (V = Math.max((I = B[x]).start, w.start), N = Math.min(I.start + I.count, w.start + w.count), T = V, E = N; T < E; T += 3)h = T, f(e, p, $, A, h, c = T + 1, d = T + 2, G), f(e, v, y, A, h, c, d, z); else for (V = Math.max(0, w.start), N = Math.min(p.count, w.start + w.count), x = V, _ = N; x < _; x += 3)h = x, f(e, p, $, A, h, c = x + 1, d = x + 2, G), f(e, v, y, A, h, c, d, z); let U = new Float32BufferAttribute(G, 3), S = new Float32BufferAttribute(z, 3); return { positionAttribute: p, normalAttribute: v, morphedPositionAttribute: U, morphedNormalAttribute: S } } function mergeGroups(e) { if (0 === e.groups.length) return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), e; let t = e.groups; if (t = t.sort((e, t) => e.materialIndex !== t.materialIndex ? e.materialIndex - t.materialIndex : e.start - t.start), null === e.getIndex()) { let r = e.getAttribute("position"), i = []; for (let o = 0; o < r.count; o += 3)i.push(o, o + 1, o + 2); e.setIndex(i) } let n = e.getIndex(), s = []; for (let u = 0; u < t.length; u++){ let l = t[u], a = l.start, f = a + l.count; for (let m = a; m < f; m++)s.push(n.getX(m)) } e.dispose(), e.setIndex(s); let g = 0; for (let h = 0; h < t.length; h++){ let c = t[h]; c.start = g, g += c.count } let d = t[0]; e.groups = [d]; for (let b = 1; b < t.length; b++){ let p = t[b]; d.materialIndex === p.materialIndex ? d.count += p.count : (d = p, e.groups.push(d)) } return e } function toCreasedNormals(e, t = Math.PI / 3) { let r = Math.cos(t), i = (1 + 1e-10) * 100, o = [new Vector3, new Vector3, new Vector3], n = new Vector3, s = new Vector3, u = new Vector3, l = new Vector3; function a(e) { let t = ~~(e.x * i), r = ~~(e.y * i), o = ~~(e.z * i); return `${t},${r},${o}` } let f = e.toNonIndexed(), m = f.attributes.position, g = {}; for (let h = 0, c = m.count / 3; h < c; h++){ let d = 3 * h, b = o[0].fromBufferAttribute(m, d + 0), p = o[1].fromBufferAttribute(m, d + 1), $ = o[2].fromBufferAttribute(m, d + 2); n.subVectors($, p), s.subVectors(b, p); let A = new Vector3().crossVectors(n, s).normalize(); for (let v = 0; v < 3; v++){ let y = o[v], B = a(y); B in g || (g[B] = []), g[B].push(A) } } let w = new Float32Array(3 * m.count), x = new BufferAttribute(w, 3, !1); for (let T = 0, _ = m.count / 3; T < _; T++){ let E = 3 * T, I = o[0].fromBufferAttribute(m, E + 0), V = o[1].fromBufferAttribute(m, E + 1), N = o[2].fromBufferAttribute(m, E + 2); n.subVectors(N, V), s.subVectors(I, V), u.crossVectors(n, s).normalize(); for (let G = 0; G < 3; G++){ let z = o[G], U = a(z), S = g[U]; l.set(0, 0, 0); for (let R = 0, X = S.length; R < X; R++){ let C = S[R]; u.dot(C) > r && l.add(C) } l.normalize(), x.setXYZ(E + G, l.x, l.y, l.z) } } return f.setAttribute("normal", x), f } function mergeBufferGeometries(e, t = !1) { return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."), mergeGeometries(e, t) } function mergeBufferAttributes(e) { return console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes()."), mergeAttributes(e) } const _cb = new Vector3, _ab = new Vector3; class SimplifyModifier{ modify(e, t) { e = e.clone(); let r = e.attributes; for (let i in r) "position" !== i && e.deleteAttribute(i); e = THREE.BufferGeometryUtils.mergeVertices(e); let o = [], n = [], s = e.getAttribute("position"); for (let u = 0; u < s.count; u++){ let l = new Vector3().fromBufferAttribute(s, u), a = new Vertex(l); o.push(a) } let f = e.getIndex(); if (null !== f) for (let m = 0; m < f.count; m += 3){ let g = f.getX(m), h = f.getX(m + 1), c = f.getX(m + 2), d = new Triangle(o[g], o[h], o[c], g, h, c); n.push(d) } else for (let b = 0; b < s.count; b += 3){ let p = b, $ = b + 1, A = b + 2, v = new Triangle(o[p], o[$], o[A], p, $, A); n.push(v) } for (let y = 0, B = o.length; y < B; y++)computeEdgeCostAtVertex(o[y]); let w, x = t; for (; x--;){ if (!(w = minimumCostEdge(o))) { console.log("THREE.SimplifyModifier: No next vertex"); break } collapse(o, n, w, w.collapseNeighbor) } let T = new BufferGeometry, _ = []; f = []; for (let E = 0; E < o.length; E++){ let I = o[E].position; _.push(I.x, I.y, I.z), o[E].id = E } for (let V = 0; V < n.length; V++){ let N = n[V]; f.push(N.v1.id, N.v2.id, N.v3.id) } return T.setAttribute("position", new Float32BufferAttribute(_, 3)), T.setIndex(f), T } } function pushIfUnique(e, t) { -1 === e.indexOf(t) && e.push(t) } function removeFromArray(e, t) { let r = e.indexOf(t); r > -1 && e.splice(r, 1) } function computeEdgeCollapseCost(e, t) { let r = t.position.distanceTo(e.position), i = 0, o = []; for (let n = 0, s = e.faces.length; n < s; n++){ let u = e.faces[n]; u.hasVertex(t) && o.push(u) } for (let l = 0, a = e.faces.length; l < a; l++){ let f = 1, m = e.faces[l]; for (let g = 0; g < o.length; g++){ let h = o[g], c = m.normal.dot(h.normal); f = Math.min(f, (1.001 - c) / 2) } i = Math.max(i, f) } o.length < 2 && (i = 1); let d = r * i + 0; return d } function computeEdgeCostAtVertex(e) { if (0 === e.neighbors.length) { e.collapseNeighbor = null, e.collapseCost = -.01; return } e.collapseCost = 1e5, e.collapseNeighbor = null; for (let t = 0; t < e.neighbors.length; t++){ let r = computeEdgeCollapseCost(e, e.neighbors[t]); e.collapseNeighbor || (e.collapseNeighbor = e.neighbors[t], e.collapseCost = r, e.minCost = r, e.totalCost = 0, e.costCount = 0), e.costCount++, e.totalCost += r, r < e.minCost && (e.collapseNeighbor = e.neighbors[t], e.minCost = r) } e.collapseCost = e.totalCost / e.costCount } function removeVertex(e, t) { for (console.assert(0 === e.faces.length); e.neighbors.length;){ let r = e.neighbors.pop(); removeFromArray(r.neighbors, e) } removeFromArray(t, e) } function removeFace(e, t) { removeFromArray(t, e), e.v1 && removeFromArray(e.v1.faces, e), e.v2 && removeFromArray(e.v2.faces, e), e.v3 && removeFromArray(e.v3.faces, e); let r = [e.v1, e.v2, e.v3]; for (let i = 0; i < 3; i++){ let o = r[i], n = r[(i + 1) % 3]; o && n && (o.removeIfNonNeighbor(n), n.removeIfNonNeighbor(o)) } } function collapse(e, t, r, i) { if (!i) { removeVertex(r, e); return } let o = []; for (let n = 0; n < r.neighbors.length; n++)o.push(r.neighbors[n]); for (let s = r.faces.length - 1; s >= 0; s--)r.faces[s] && r.faces[s].hasVertex(i) && removeFace(r.faces[s], t); for (let u = r.faces.length - 1; u >= 0; u--)r.faces[u].replaceVertex(r, i); removeVertex(r, e); for (let l = 0; l < o.length; l++)computeEdgeCostAtVertex(o[l]) } function minimumCostEdge(e) { let t = e[0]; for (let r = 0; r < e.length; r++)e[r].collapseCost < t.collapseCost && (t = e[r]); return t } class Triangle{ constructor(e, t, r, i, o, n) { this.a = i, this.b = o, this.c = n, this.v1 = e, this.v2 = t, this.v3 = r, this.normal = new Vector3, this.computeNormal(), e.faces.push(this), e.addUniqueNeighbor(t), e.addUniqueNeighbor(r), t.faces.push(this), t.addUniqueNeighbor(e), t.addUniqueNeighbor(r), r.faces.push(this), r.addUniqueNeighbor(e), r.addUniqueNeighbor(t) } computeNormal() { let e = this.v1.position, t = this.v2.position, r = this.v3.position; _cb.subVectors(r, t), _ab.subVectors(e, t), _cb.cross(_ab).normalize(), this.normal.copy(_cb) } hasVertex(e) { return e === this.v1 || e === this.v2 || e === this.v3 } replaceVertex(e, t) { e === this.v1 ? this.v1 = t : e === this.v2 ? this.v2 = t : e === this.v3 && (this.v3 = t), removeFromArray(e.faces, this), t.faces.push(this), e.removeIfNonNeighbor(this.v1), this.v1.removeIfNonNeighbor(e), e.removeIfNonNeighbor(this.v2), this.v2.removeIfNonNeighbor(e), e.removeIfNonNeighbor(this.v3), this.v3.removeIfNonNeighbor(e), this.v1.addUniqueNeighbor(this.v2), this.v1.addUniqueNeighbor(this.v3), this.v2.addUniqueNeighbor(this.v1), this.v2.addUniqueNeighbor(this.v3), this.v3.addUniqueNeighbor(this.v1), this.v3.addUniqueNeighbor(this.v2), this.computeNormal() } } class Vertex{ constructor(e) { this.position = e, this.id = -1, this.faces = [], this.neighbors = [], this.collapseCost = 0, this.collapseNeighbor = null } addUniqueNeighbor(e) { pushIfUnique(this.neighbors, e) } removeIfNonNeighbor(e) { let t = this.neighbors, r = this.faces, i = t.indexOf(e); if (-1 !== i) { for (let o = 0; o < r.length; o++)if (r[o].hasVertex(e)) return; t.splice(i, 1) } } }
// Simplify-modifier Component
AFRAME.registerComponent('simplify-modifier', {
	schema: {
	  color: { type: 'color', default: '#ffffff' },
		wireframe: { type: 'boolean', default: false },
		count: { type: 'number', default: 0.7 },
		offset: { type: 'number', default: 1 }
	},
	init: function () {
	  let scene = document.querySelector("a-scene").object3D;
	  let gltfModel = this.el;
	  gltfModel.addEventListener('model-loaded', (e) => {
		let gltfModelMesh = e.detail.model.children[0];
		const modifier = new SimplifyModifier();
		const simplified = gltfModelMesh.clone();
		simplified.material = simplified.material.clone();
		simplified.material.flatShading = true;
		let color = this.data.color;
		simplified.material.color = new THREE.Color(color);

		if (this.data.wireframe) {
		  simplified.material.wireframe = true;
		}
		const count = Math.floor(simplified.geometry.attributes.position.count * this.data.count); // number of vertices to remove
        simplified.geometry = modifier.modify(simplified.geometry, count);
		// Copy position, rotation and scale
		simplified.position.copy(gltfModel.object3D.position);
		// Position model near original
		simplified.position.x = this.data.offset;
		simplified.rotation.copy(gltfModel.object3D.rotation);
		simplified.scale.copy(gltfModel.object3D.scale);
		scene.add(simplified);
	  });
	}
  });
